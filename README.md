Данное приложение представляет собой компилятор с работающий сканером и парсером, реализованный с помощью Windows Forms на языке C#. Ниже подробно описаны все функции, доступные пользователю.

Вариант задания - Словарь с инициализацией на языке Python
Меню "Файл"

    Создать документ – Очищает текущее текстовое поле и начинает работу с новым пустым документом. При этом сбрасывается предыдущий путь к файлу.
    Открыть документ – Позволяет выбрать и загрузить существующий текстовый файл (.txt) в редактор для дальнейшего редактирования.
    Сохранить документ – Сохраняет текущие изменения в уже открытом файле. Если документ новый, предлагается выбрать имя и место сохранения.
    Сохранить как – Открывает диалоговое окно для сохранения документа под новым именем или в другом месте.
    Выход – Завершает работу приложения.

Меню "Правка"

    Отменить (Undo) – Отменяет последнее выполненное действие, позволяя вернуться к предыдущему состоянию текста.
    Повторить (Redo) – Повторяет последнее отменённое действие, восстанавливая изменения.
    Копировать – Копирует выделенный текст в буфер обмена для последующей вставки.
    Вырезать – Удаляет выделенный текст из документа, сохраняя его в буфер обмена.
    Вставить – Вставляет текст из буфера обмена в текущую позицию курсора.
    Удалить – Удаляет выделенный текст без помещения его в буфер обмена.
    Выделить всё – Выделяет весь текст в документе для дальнейших операций (копирования, удаления и т.д.).

Меню "Справка"

    Вызов справки – Открывает данную HTML-страницу с подробным описанием функционала приложения.
    О программе – Выводит информацию о приложении, включая его название, версию, данные об авторе и копирайте.

Панель инструментов (ToolStrip)

    Создание документа – Быстрый доступ к функции создания нового документа (аналог пункта меню "Создать документ").
    Открытие документа – Позволяет быстро открыть существующий текстовый файл, аналогично функции из меню "Открыть документ".
    Сохранение изменений – Сохраняет текущие изменения в документе, эквивалентно пункту меню "Сохранить документ".
    Отмена изменений – Отменяет последнее действие (аналог функции "Отменить").
    Повтор последнего изменения – Повторяет отменённое действие (аналог функции "Повторить").
    Копировать текстовый фрагмент – Копирует выделенный фрагмент текста в буфер обмена (функция "Копировать").
    Вырезать текстовый фрагмент – Вырезает выделенный текст, сохраняя его для возможной вставки (функция "Вырезать").
    Вставить текстовый фрагмент – Вставляет текст из буфера обмена в документ (функция "Вставить").
    Запуск синтаксического анализатора – Кнопка предназначена для запуска синтаксического анализатора кода. На данном этапе функциональность не реализована и кнопка не выполняет никаких действий.
    Вызов справки – Позволяет вызвать справочную систему, открывая данную HTML-страницу с описанием функций.
    Вызов информации о программе – Отображает сведения о приложении, аналогично функции "О программе" в меню.

Грамматика языка:

1.	‹List› → ‹Letter›‹I›
2.	‹I› → ‹Letter›‹I›
3.	‹I› → ‹=›‹O›
4.	‹O› → ‹[›‹P›
5.	‹P› → ‹+|–›‹T›
6.	‹P› → ‹Digit›‹TR›
7.	‹P› → ‹”›‹S›
8.	‹P› → ‹]›‹E›
9.	‹T› → ‹Digit›‹TR›
10.	‹TR› → ‹Digit›‹TR›
11.	‹TR› → ‹,›‹P›
12.	‹TR› → ‹.›‹F›
13.	‹TR› → ‹]›‹E›
14.	‹F› → ‹Digit›‹FR›
15.	‹FR› → ‹Digit›‹FR›
16.	‹FR› → ‹,›‹P›
17.	‹FR› → ‹]›‹E›
18.	‹S› → ‹Letter | Digit›‹SR›
19.	‹SR› → ‹Letter | Digit›‹SR›
20.	‹SR› → ‹”›‹A›
21.	‹A› → ‹,›‹P›
22.	‹A› → ‹]›‹E›
23.	‹E› → ‹;›
•	‹Digit› → “0” | “1” | “2” | “3” | “4” | “5” | “6” | “7” | “8” | “9”
•	‹Letter› → “a” | “b” | “c” | ... | “z” | “A” | “B” | “C” | ... | “Z”

Классификация грамматики -- праворекурсивная

Правила, где рекурсивный вызов нетерминала находится в крайней правой позиции, что соответствует форме A → aB.
В данной грамматике такими являются:
(2) ‹I› → ‹Letter›‹I›
(10) ‹TR› → ‹Digit›‹TR›
(15) ‹FR› → ‹Digit›‹FR›
(19) ‹SR› → ‹Letter | Digit›‹SR›

Остальные правила не содержат рекурсии или завершают цепочку продукций терминальным символом (правило (23) ‹E› → ‹;›).
Поскольку все правила продукции имеют форму либо A → aB, либо A → a, грамматика является праворекурсивной и, следовательно, соответствует автоматной грамматике (регулярной грамматике, тип-3 по классификации Хомского). Это удовлетворяет требованию о том, что все правила должны быть либо леворекурсивными, либо праворекурсивными – в нашем случае они однородно праворекурсивные.


Примеры допустимых строк:

1.	Список целых чисел – последовательность целых чисел, например: List = [1, 2, 3, 4];
2.	Список строк – последовательность строковых значений, например: List = ["a", "b", "c"];
3.	Список с различными типами данных – список, содержащий различные типы данных, например: List = [1, "a", 3.14];


Диаграмма состояний:

![схема строки](https://github.com/user-attachments/assets/193b2642-e414-4123-aa49-7ac09c494c40)


Граф автомата:

![граф новый](https://github.com/user-attachments/assets/6e45d16a-2d42-45c2-a6e0-41e08748fe38)


Тестовые примеры:

![изображение](https://github.com/user-attachments/assets/1ca9750a-9590-4121-b79d-377cd8306f21)


![изображение](https://github.com/user-attachments/assets/df162cbc-46b5-468f-b024-afaf5dd53d62)


![изображение](https://github.com/user-attachments/assets/5916779f-b471-4222-84f6-4303c800de42)


В ходе выполнения 5 лабораторной был закомментирован лексер и парсер для первых 4-х лабораторных и был написан новый лексер и новый парсер уже для 5-ой.
Чтобы заработали первые 4 лабораторных, достаточно раскомментировать исходный код и закомментировать новый


Суть 5-ой лабораторной -- Выполнить разбор строки в виде тетрад

1) Реализовать в текстовом редакторе поиск лексических и синтаксических ошибок для грамматики G[<E>]. Реализовать данную КС-граммматику методом рекурсивного спуска:

1. E → TA 

2. A → ε | + TA | - TA 

3. T → ОВ 

4. В → ε | *ОВ | /ОВ 

5. О → id | (E) 

6. id → letter {letter}

2) Реализовать алгоритм записи выражений в форме тетрад.



Примеры верных строк:

1. a + b * (c - d)
2. ((a+b)/(c*d)) - k - t
3. c = a + b

Тестовые примеры:

![изображение](https://github.com/user-attachments/assets/408664b2-d03d-441b-82f0-c93239c2af34)

![изображение](https://github.com/user-attachments/assets/bd0608aa-3204-408b-9ba3-bab4f3be16d0)

![изображение](https://github.com/user-attachments/assets/5afe7477-9123-431a-8e75-afbe11ac7daf)

6 лабораторная:

Решение 1 блока задач:


private static readonly Regex PassportRx = new Regex(@"\b\d{4}[-\s]?\d{6}\b");

Решение 2 блока задач:


private static readonly Regex CommentRx = new Regex(@"(?s)(\"""".*?\""""|'''.*?''')", RegexOptions.Singleline);

Решение 3 блока задач:

private static readonly Regex HslRx = new Regex(@"\bhsl\(\s*(?:3[0-5]\d|360|[12]?\d{1,2})\s*,\s*(?:100|[1-9]?\d)%\s*,\s*(?:100|[1-9]?\d)%\s*\)");


Тестовые примеры:

![изображение](https://github.com/user-attachments/assets/91259fe3-de65-4d0b-a8b1-4bdacc8503fa)


![изображение](https://github.com/user-attachments/assets/ad6c4913-1c5f-42b4-bc3d-07b694d9c961)


![изображение](https://github.com/user-attachments/assets/e98a5ab4-cb56-444a-8804-3b88b6617e68)



Лабораторная работа №8

# Рекурсивный спуск для варианта 11

## Грамматика

```
G[S]:
1. S → NP VP
2. NP → Pro | PropN | Det A Nom | Det Nom
3. Nom → Nom PP | N Nom | N
4. VP → VP PP | V NP | V NP PP | V PP
5. PP → P NP
N → flight | passenger | trip | morning | ...
V → is | prefers | like | need | depend | fly | ...
A → cheapest | non-stop | first | latest other | direct | ...
Pro → me | I | you | it | ...
PropN → Alaska | Baltimore | Los Angeles | Chicago | ...
Det → the | a | an | this | these | that | ...
P → from | to | on | near | ...
```

Примечание: грамматика реализует составление простейших предложений на английском языке

![изображение](https://github.com/user-attachments/assets/a267e892-713e-4a37-8059-abed9bb24437)



## Язык
- **C#**, Windows Forms (.NET Framework)
- Лексер и парсер объединены в одном проекте `Laba1`

## Классификация грамматики
- **Контекстно-свободная грамматика (КС)**  

## Схема вызова функций
```
ParseS
├─ вызывает ParseNP
└─ вызывает ParseVP

ParseNP
├─ в одном из вариантов вызывает ParseNom
└─ (при других вариантах) напрямую обрабатывает Pro или PropN

ParseNom
├─ сначала делает Match(N)
├─ затем в цикле может вызывать ParsePP (если встречается предлог) или снова делать Match(N) для вложенного существительного
└─ цикл повторяется до тех пор, пока не удаётся применить ни один из вариантов

ParseVP
├─ сначала делает Match(V)
├─ затем пытается вызвать ParseNP (если после глагола идёт номинативная группа)
│ └─ в этом же варианте может опционально вызвать ParsePP
└─ или (в случае, если нет NP) сразу вызвать ParsePP (если после глагола идёт предлог)

ParsePP
├─ сначала делает Match(P)
└─ затем вызывает ParseNP (после предлога обязательно должна идти номинативная группа)
```

## Тестовые примеры
### Корректные
```I would like to swim```


![изображение](https://github.com/user-attachments/assets/0dcd876e-deae-40a1-a94c-59d1636c719e)


```I like you```


![изображение](https://github.com/user-attachments/assets/22ccb1a8-c23c-48c2-aac8-3dcec527f72c)


### С ошибками
```I you how there```


![изображение](https://github.com/user-attachments/assets/9e6b0cea-8a02-4547-9c31-2e95c1442547)

```Know you swim like he```


![изображение](https://github.com/user-attachments/assets/c58f6014-1aed-4212-b65b-de494421e573)


# Дополнительное задание к варианту 11

## Диаграмма сканера
```
Start – точка начала сканирования.

GetChar – читаем следующий символ/слово из входной строки.

IsEOF – проверяем, не достигли ли конца входной последовательности.

Если да, переходим в блок End.

Если нет, продолжаем дальше.

IsWhitespace? – если прочитанный символ пробельный (пробел, таб, перевод строки):
    Да → идём в блок Advance (инкремент позиции, читаем следующий символ) и возвращаемся в GetChar.
    Нет → переходим дальше.    

IsLetter? – если символ является буквой:

    Да → ReadIdentifier (считываем всю последовательность букв/цифр/ подчёркиваний, формируем идентификатор или ключевое слово), затем возвращаемся в GetChar.
    Нет → проверяем далее.

IsQuote? – если символ является двойной кавычкой ":

    Да → ReadString (читаем всё внутри кавычек до следующей ", формируем токен StringLiteral или ошибку при незакрытой строке), затем возвращаемся в GetChar.
    Нет → проверяем дальше.

IsKnownSymbol? – проверяем, является ли текущий символ (или последовательность символов) одним из одиночных терминалов (например, =, :, ;, &str и т. п.).

    Да → AddToken (создаём соответствующий токен и переходим в GetChar).
    Нет → ErrorToken (сгенерировать токен-ошибку Unknown и записать сообщение об ошибке), затем переходим в GetChar.

End – завершение работы сканера.
```

## Тестовые примеры
### Корректные строки
```passenger from flight```

![изображение](https://github.com/user-attachments/assets/396c18d6-6903-4176-9e0e-a103880a741c)


### Лексические ошибки
```passenger from@@фалытид flight```

![изображение](https://github.com/user-attachments/assets/5749912a-3edc-4b1a-9009-ef4d6e0eae27)


### Синтаксические ошибки
```passenger form me like you```

![изображение](https://github.com/user-attachments/assets/5efa9be5-236d-4493-8a29-eab981f021c3)

